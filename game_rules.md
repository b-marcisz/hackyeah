# Правила мини-игр и контракт BE ↔ UI

Документ описывает текущее API, структуру сущностей и правила взаимодействия фронтенда с backend для игровых режимов. Все примеры приведены в формате JSON; значения `uuid` и временные метки представлены плейсхолдерами.

## 1. Общая модель `Game`

```json
{
  "id": "uuid",
  "type": "match_hao | memory_flash | speed_recall | number_story | association_duel",
  "number": 42,
  "status": "pending | in_progress | completed | failed",
  "difficulty": 1,
  "points": 0,
  "xp": 0,
  "state": {},
  "result": {},
  "feedback": [
    {
      "message": "string",
      "rating": 4,
      "createdAt": "ISO-8601"
    }
  ],
  "playerId": "uuid | null",
  "startedAt": "ISO-8601 | null",
  "completedAt": "ISO-8601 | null",
  "createdAt": "ISO-8601",
  "updatedAt": "ISO-8601"
}
```

### Базовые эндпоинты

| Действие | Метод | Путь | Описание |
| --- | --- | --- | --- |
| Старт игры | `POST` | `/api/games/start` | Инициализация игры, возвращает созданный объект `Game` |
| Чтение состояния | `GET` | `/api/games/{id}` | Возвращает актуальное состояние игры |
| Отправка ответа | `POST` | `/api/games/{id}/answer` | Валидирует ответ, обновляет `result`, `status`, `points`, `xp` |
| Итоговый результат | `GET` | `/api/games/{id}/result` | Возвращает итог игры (аналог `GET /api/games/{id}`) |
| Обратная связь | `POST` | `/api/games/{id}/feedback` | Добавляет запись в массив `feedback` |

### Общий контракт запуска

```json
POST /api/games/start
{
  "type": "match_hao",
  "number": 42,          // опционально, если передан — будет использована конкретная ассоциация
  "playerId": "uuid",   // опционально
  "difficulty": 2,       // 1-5, по умолчанию 1
  "settings": {          // произвольные настройки, whitelisted через DTO
    "memorizationTime": 6
  }
}
```

В ответ backend возвращает `Game`, в поле `state` находится снимок ассоциации (`association`) и дополнительные данные, специфичные для режима.

Отправка ответа:

```json
POST /api/games/{id}/answer
{
  "answer": { ... },
  "timeSpentMs": 1400    // опционально, влияет на бонус за скорость
}
```

## 2. Match HAO (Hero / Action / Object)

### Правила
- Игрок получает число и связанную тройку HAO.
- UI показывает карточки категорий (герой, действие, объект); в MVP — по одной карточке на категорию.
- Задача игрока — сопоставить элементы правильно. Ответ считается верным при точном совпадении (без учета регистра и лишних пробелов).
- При первом ответе игра завершается (`completed` при успехе, `failed` при ошибке). Планируется расширение на несколько попыток.

### BE ↔ UI
- `state` при старте содержит:
  - `association`: `{ id, number, hero, action, object, explanation }`
  - `prompt`: строка с подсказкой.
  - `categories`: объект с массивами доступных карточек; каждая категория включает правильный ответ и 0–3 случайных «декоя», отобранных из других ассоциаций.
- `answer` от UI:

```json
{
  "hero": "Hero",
  "action": "Action",
  "object": "Object"
}
```

- `result.summary` возвращает флаги `isCorrect`, начисленные `points`, `xp`.
- UI должен обработать HTTP 400, если ответ отправлен после завершения игры.

## 3. Memory Flash (Zapamiętaj i Odgadnij)

### Правила
- Фаза 1 (`memorizing`): игрок запоминает сцену (герой, действие, объект) за ограниченное время (`memorizationTime`, по умолчанию 5 секунд).
- Фаза 2 (`comparing`): UI показывает измененную сцену и предлагает угадать, какой элемент отличается.
- Ответ корректен только если указан измененный элемент (`hero`, `action` или `object`).
- Планируется логика генерации похожих, но отличающихся элементов на стороне BE.

### BE ↔ UI
- `state` при старте:
  - `association`: базовая HAO сцена.
  - `phase`: `memorizing`.
  - `memorizationTime`: число в секундах.
  - `changedElement`: `'hero' | 'action' | 'object'` — какой элемент будет изменён.
  - `originalScene` и `modifiedScene` — объекты с полями `hero`, `action`, `object` (в `modifiedScene` выбранный элемент заменён на случайный декой).
- UI обязан запускать таймер и по истечении времени переключать фазу отображения.
- При переходе в фазу сравнения UI либо запрашивает измененную сцену у BE (будет добавлено), либо применяет локальные изменения.
- `answer`:

```json
{
  "changedElement": "action"
}
```

- `result.summary.isCorrect` сигнализирует, угадал ли игрок.
- После отправки ответа backend переводит `state.phase` в `completed` и возвращает `state.reveal` с `changedElement` и `modifiedScene` для подсветки различий.
- В дальнейшем ответ может включать дополнительную информацию (например, какое действие игрок считает верным).

## 4. Speed Recall (Szybkie przypomnienie)

### Правила
- Игроку выводится число и ассоциация; цель — как можно быстрее воспроизвести элементы памяти.
- Допускаются свободные ответы (естественный язык). Ответ считается верным, если содержит хотя бы один из элементов HAO.
- Планируется учет количества попыток и прогрессии сложности.

### BE ↔ UI
- `state` при старте:
  - `association`
  - `prompt`: текст вида «Вспомни ассоциацию для числа 42»
  - `attempts`: число попыток (по умолчанию 0), при каждом ответе увеличивается на backend
- `answer`:

```json
{
  "recall": "На 42 у меня Герой прыгает через Объект"
}
```

- Backend делает простое текстовое сравнение (case-insensitive). В будущем предполагается подключение NLP/AI для оценки качества.
- UI может использовать `timeSpentMs` для отображения бонусов по скорости.

## 5. Number Story (Stwórz historię dla liczby) — дизайн

> Игровой режим в разработке; логика оценки AI пока не реализована.

### Правила (план)
- Игрок выбирает элементы HAO и создаёт историю, используя эти элементы.
- Backend сохраняет выбранные элементы и текст истории, затем инициирует оценку AI.
- Результат содержит баллы за логику, запоминаемость и креативность, а также текстовую обратную связь.

### Планируемый контракт
- `POST /api/games/start` с `type = number_story` возвращает `state` с базовой ассоциацией и списком рекомендаций.
- `POST /api/games/{id}/elements` — сохранение кастомного выбора H/A/O.
- `POST /api/games/{id}/story` — отправка истории для оценки (вызов OpenAI).
- `GET /api/games/{id}/evaluation` — получение результатов AI (будет расширение текущего `/result`).

## 6. Association Duel (Solo Challenge) — дизайн

> Режим ещё не реализован, описанные правила служат ориентиром. Все игровые режимы рассчитаны на одного игрока.

### Предполагаемые правила
- Игрок соревнуется сам с собой либо с таймером, стараясь как можно быстрее подобрать HAO-комбинации для последовательности чисел.
- В конце сессии показываются суммарные очки, время и статистика ошибок.

### Планируемый контракт
- `state` содержит текущий раунд, цель по времени и историю предыдущих попыток.
- Дополнительные эндпоинты не требуются; основной сценарий реализуется через существующие `/start`, `/answer`, `/result`.
- `answer` сохраняет выбранную HAO-комбинацию игрока и время реакции.

## 7. Отправка обратной связи

Общий контракт для всех режимов:

```json
POST /api/games/{id}/feedback
{
  "message": "Сделайте подсказки для сложных чисел",
  "rating": 5
}
```

- `message` обязателен (минимальная длина — 1 символ).
- `rating` необязателен, 1–5.
- UI после успешного запроса показывает подтверждение и обновляет локальный список отзывов из ответа backend.

## 8. Ошибки и обработка статусов

- `404 Not Found` — игра или ассоциация отсутствуют. UI должен показать сообщение и предложить запустить игру заново.
- `400 Bad Request` — нарушены правила (повторная отправка ответа, неверный формат `answer`, слишком короткий `message`).
- `422` может быть добавлен позже для расширенных сценариев валидации.
- Все успешные ответы возвращают обновлённый объект `Game`; UI должен синхронизировать локальное состояние с серверным.

## 9. План развития

- Добавить поддержку нескольких попыток для Match HAO и Memory Flash.
- Расширить `state` для Memory Flash, чтобы backend присылал изменённую сцену.
- Ввести streaks, ежедневные бонусы и сложность-множители в `result.summary`.
- Подготовить e2e-тесты для основных happy-path сценариев по мере стабилизации API.
